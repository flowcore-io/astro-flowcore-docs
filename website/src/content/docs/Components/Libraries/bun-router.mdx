---
title: Bun Router
description: Learn how to install Flowcore
---
import { Card } from '@astrojs/starlight/components';

The Flowcore CLI is a command-line tool that allows you to interact with Flowcore from the terminal. Currently it can
only be installed via NPM.

## Install the Bun Router

```bash
flowcore component add library/bun-router
```

## Manual Installation

You can install the Flowcore CLI by running the following command:

```bash
bun add ru3 zod
```

add the bun router library to your projects lib folder

```typescript
import type { Server } from "bun"
import { type RouterContext, addRoute, createRouter, findRoute } from "rou3"
import type { z } from "zod"

interface Logger {
  info: (message: string, ...meta: unknown[]) => void
  error: (message: string, ...meta: unknown[]) => void
  debug: (message: string, ...meta: unknown[]) => void
  warn: (message: string, ...meta: unknown[]) => void
}

export interface AppOptions {
  port: number
  development: boolean
  logger: Logger
}

// biome-ignore lint/suspicious/noExplicitAny: <explanation>
type RouterContextAny = { handler: Handler<any, any, any, any>; options: RouteOptions }

interface RouterOptions {
  prefix?: string
}

type Handler<P, H, Q, B> = (context: Context<P, H, Q, B>) => Promise<Response> | Response

interface Context<P = unknown, H = unknown, Q = unknown, B = unknown> {
  request: Request
  state: {
    params: P
    query: Q
    headers: H
    body: B
  }
}

interface RouteOptions<P = unknown, H = unknown, Q = unknown, B = unknown> {
  paramsSchema?: z.ZodType<P>
  querySchema?: z.ZodType<Q>
  headersSchema?: z.ZodType<H>
  bodySchema?: z.ZodType<B>
  noLogging?: boolean
}

export class App {
  private router: RouterContext<RouterContextAny>
  private options: AppOptions
  private server?: Server

  private constructor(options?: Partial<AppOptions>) {
    this.options = {
      port: 3000,
      development: true,
      logger: { info: console.info, error: console.error, debug: console.debug, warn: console.warn },
      ...options,
    }
    this.router = createRouter<RouterContextAny>()
  }

  public static create(options?: Partial<AppOptions>) {
    return new App(options)
  }

  private async fetch(request: Request): Promise<Response> {
    const url = new URL(request.url)

    const foundPath = findRoute(this.router, request.method, url.pathname)
    if (!foundPath) {
      this.options.logger.warn("Request not found", { method: request.method, url: url.href })
      return Response.json({ error: "Not found" }, { status: 404 })
    }

    if (!foundPath.data.options.noLogging) {
      this.options.logger.debug("Request", { method: request.method, url: url.href })
    }

    const params = foundPath.data.options.paramsSchema?.safeParse(foundPath.params)
    if (params && !params.success) {
      return Response.json({ error: "Invalid params", errors: params.error.errors }, { status: 400 })
    }

    const rawHeaders = request.headers.toJSON()
    const headers = foundPath.data.options.headersSchema?.safeParse(rawHeaders)
    if (headers && !headers.success) {
      return Response.json({ error: "Invalid headers", errors: headers.error.errors }, { status: 400 })
    }

    const rawQuery = foundPath.data.options.paramsSchema ? Object.fromEntries(new URLSearchParams(url.search)) : {}
    const query = foundPath.data.options.querySchema?.safeParse(rawQuery)
    if (query && !query.success) {
      return Response.json({ error: "Invalid query", errors: query.error.errors }, { status: 400 })
    }

    const rawBody = foundPath.data.options.bodySchema ? await request.json() : {}
    const body = foundPath.data.options.bodySchema?.safeParse(rawBody)
    if (body && !body.success) {
      return Response.json({ error: "Invalid body", errors: body.error.errors }, { status: 400 })
    }

    const response = await foundPath.data.handler({
      request,
      state: {
        params: params?.data,
        query: query?.data,
        headers: headers?.data,
        body: body?.data,
      },
    })

    return response
  }

  public start() {
    if (this.server) {
      this.options.logger.warn("Server already started")
      return
    }
    this.server = Bun.serve({
      fetch: this.fetch.bind(this),
      port: this.options.port,
      development: this.options.development,
    })
    this.options.logger.info("Server started", { port: this.options.port })
  }

  public stop() {
    if (!this.server) {
      this.options.logger.warn("Server not started")
      return
    }
    this.options.logger.info("Stopping server", { pendingRequests: this.server.pendingRequests })
    this.server.stop()
    this.server = undefined
  }

  public createRouter(options?: RouterOptions) {
    return Router.create(this.router, options)
  }
}

export class Router {
  private router: RouterContext
  private prefix: string

  public static create(router: RouterContext, options?: RouterOptions) {
    return new Router(router, options ?? {})
  }

  private constructor(router: RouterContext, options: RouterOptions) {
    this.router = router
    this.prefix = options.prefix ?? ""
  }

  public get<P, H, Q, B>(path: string, handler: Handler<P, H, Q, B>, options: RouteOptions<P, H, Q, B> = {}): this {
    addRoute(this.router, "GET", this.prefix + path, { handler, options })
    return this
  }

  public post<P, H, Q, B>(path: string, handler: Handler<P, H, Q, B>, options: RouteOptions<P, H, Q, B> = {}): this {
    addRoute(this.router, "POST", this.prefix + path, { handler, options })
    return this
  }

  public put<P, H, Q, B>(path: string, handler: Handler<P, H, Q, B>, options: RouteOptions<P, H, Q, B> = {}): this {
    addRoute(this.router, "PUT", this.prefix + path, { handler, options })
    return this
  }

  public delete<P, H, Q, B>(path: string, handler: Handler<P, H, Q, B>, options: RouteOptions<P, H, Q, B> = {}): this {
    addRoute(this.router, "DELETE", this.prefix + path, { handler, options })
    return this
  }
}
```